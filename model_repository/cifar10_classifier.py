"""
@author: staceytruex

Model architecture source: https://keras.io/examples/cifar10_cnn/
"""
import numpy as np
import os
os.environ["CUDA_DEVICE_ORDER"] = "PCI_BUS_ID"
os.environ["CUDA_VISIBLE_DEVICES"] = '-1'
import keras
from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D
from keras.layers import Dense, Activation, Flatten, Dropout
import keras.backend as K
import gc


def build_cnn(X_train, Y_train):
    model = Sequential()
    model.add(Conv2D(32, (3, 3), padding='same', input_shape=X_train.shape[1:]))
    model.add(Activation('relu'))
    model.add(Conv2D(32, (3, 3)))
    model.add(Activation('relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(0.25))
    
    model.add(Conv2D(64, (3, 3), padding='same'))
    model.add(Activation('relu'))
    model.add(Conv2D(64, (3, 3)))
    model.add(Activation('relu'))
    model.add(MaxPooling2D(pool_size=(2, 2)))
    model.add(Dropout(0.25))
    
    model.add(Flatten())
    model.add(Dense(512))
    model.add(Activation('relu'))
    model.add(Dropout(0.5))
    model.add(Dense(len(np.unique(Y_train))))
    model.add(Activation('softmax'))
    return model


class Model:
    def __init__(self, model=None, num_epochs=100, batch_size=32,
                 learning_rate=0.0001, decay=1e-6, loss='categorical_crossentropy'):
        self.model = model
        self.num_epochs = num_epochs
        self.batch_size = batch_size
        self.learning_rate = learning_rate
        self.decay = decay
        self.loss = loss
    
    def train(self, train_data, test_data):
        X_train, Y_train = train_data
        X_test, Y_test = test_data
        
        model = build_cnn(X_train, Y_train)
        num_classes = len(np.unique(np.concatenate([Y_train, Y_test])))
        
        Y_train = keras.utils.to_categorical(Y_train, num_classes)
        Y_test = keras.utils.to_categorical(Y_test, num_classes)
        
        opt = keras.optimizers.RMSprop(lr=self.learning_rate, decay=self.decay)

        model.compile(loss=self.loss,
                      optimizer=opt,
                      metrics=['accuracy'])
        
        model.fit(X_train, Y_train,
                  batch_size=self.batch_size,
                  epochs=self.num_epochs,
                  validation_data=(X_test, Y_test),
                  shuffle=True,
                  verbose=2)            
        self.model = model
    
    def evaluate(self, eval_data):
        eval_data = eval_data.astype('float32')
        eval_data /= 255
        return self.model.predict(eval_data, batch_size=self.batch_size)
    
    def clear_model(self):
        self.model = None
        K.clear_session()
        gc.collect()
