"""
@author: staceytruex
"""
import numpy as np
import os
os.environ["CUDA_DEVICE_ORDER"] = "PCI_BUS_ID"
os.environ["CUDA_VISIBLE_DEVICES"] = '-1'
import keras
from keras import Sequential
from keras.layers import Dense
import keras.backend as K
import gc
from keras.callbacks import EarlyStopping


def get_model(n_in, n_out):
    n_nodes = int(np.ceil(np.sqrt(n_in)))
    
    model = Sequential() 
    model.add(Dense(n_nodes, input_shape = n_in, activation='relu'))
    model.add(Dense(n_out, activation='softmax')) 
    return model


class Model:
    def __init__(self, model=None, batch_size=100, epochs=50, learning_rate=0.01, l2_ratio=1e-6,
                 loss='categorical_crossentropy', optimizer='sgd'):
        self.model = model
        self.batch_size = batch_size
        self.epochs = epochs
        self.learning_rate = learning_rate
        self.l2_ratio = l2_ratio
        self.loss = loss
        self.optimizer = optimizer
    
    def train(self, train_data, test_data):
        train_x, train_y = train_data
        test_x, test_y = test_data
        
        n_in = train_x.shape[1:]
        n_out = len(np.unique(np.concatenate([train_y, test_y])))
        
        batch_size = min(self.batch_size, len(train_y))
        attack_model = get_model(n_in, n_out)
        attack_model.compile(optimizer=self.optimizer, loss=self.loss, metrics=['accuracy'])
        
        train_y = keras.utils.to_categorical(train_y, n_out)
        test_y = keras.utils.to_categorical(test_y, n_out)

        es = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=5)
        
        attack_model.fit(train_x, train_y,
                         epochs=self.epochs,
                         batch_size=batch_size,
                         validation_data=(test_x, test_y),
                         shuffle=True,
                         verbose=2,
                         callbacks=[es])
        
        self.model = attack_model
    
    def evaluate(self, eval_data):
        batch_size = min(self.batch_size, len(eval_data))
        return self.model.predict(eval_data, batch_size=batch_size)
    
    def clear_model(self):
        self.model = None
        K.clear_session()
        gc.collect()
