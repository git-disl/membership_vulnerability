"""
@author: staceytruex
"""
import numpy as np
import importlib.machinery


def divide_data(attacker_data, sample):
    shadow_x, shadow_y = attacker_data
    indices = np.arange(len(shadow_y))
    if sample:
        indices = np.random.choice(indices, int(np.ceil(len(indices)*0.67)), replace=False)
    train_indices = np.random.choice(indices, int(len(indices)/2), replace=False)
    test_indices = np.setdiff1d(indices, train_indices)
    train_x, train_y = shadow_x[train_indices], shadow_y[train_indices]
    test_x, test_y = shadow_x[test_indices], shadow_y[test_indices]
    y_vals = np.unique(shadow_y)
    for y in y_vals:
        if len(train_y[train_y == y]) == 0:
            indices = np.arange(len(test_y))[np.squeeze(test_y == y)]
            y_index = np.random.choice(indices, 1)
            train_x, train_y = np.append(train_x, test_x[y_index], axis=0), np.append(train_y, test_y[y_index], axis=0)
            test_x, test_y = np.delete(test_x, y_index, axis=0), np.delete(test_y, y_index, axis=0)
        if len(test_y[test_y == y]) == 0:
            indices = np.arange(len(train_y))[np.squeeze(train_y == y)]
            y_index = np.random.choice(indices, 1)
            test_x, test_y = np.append(test_x, train_x[y_index], axis=0), np.append(test_y, train_y[y_index], axis=0)
            train_x, train_y = np.delete(train_x, y_index, axis=0), np.delete(train_y, y_index, axis=0)
    return train_x, train_y, test_x, test_y


def balance_attack_data(train_x, train_y, test_x, test_y):
    if len(train_y) == len(test_y):
        return (train_x, train_y), (test_x, test_y)
    if len(train_y) > len(test_y):
        indices = np.random.choice(np.arange(len(train_y)), len(test_y), replace=False)
        return (train_x[indices], train_y[indices]), (test_x, test_y)
    indices = np.random.choice(np.arange(len(test_y)), len(train_y), replace=False)
    return (train_x, train_y), (test_x[indices], test_y[indices])


# noinspection PyBroadException
def import_model(model_loc):
    try:
        module = importlib.machinery.SourceFileLoader('Model', model_loc).load_module()
    except:
        print('Error loading ' + model_loc + '.')
        return None
    try:
        Model = getattr(module, 'Model')
    except:
        print('Error loading Model class from ' + model_loc + '.')
        return None
    return Model()


def attack(attacker_data, n_shadow, shadow_model_def, attack_model_def,
           labels, attack_test_in, attack_test_out, test_o_data):

    attack_test_in_x, c_in = attack_test_in
    attack_test_out_x, c_out = attack_test_out
    attack_test_x = np.concatenate([attack_test_in_x, attack_test_out_x])
    attack_test_y = np.concatenate([np.array([1]*len(c_in)), np.array([0]*len(c_out))])
    classes = np.concatenate([c_in, c_out])
    
    attack_x, attack_y = [], []
    attack_classes = []

    sample = (n_shadow > 1)

    for i in range(n_shadow):
        print('Training shadow model {}'.format(i+1))
        train_x, train_y, test_x, test_y = divide_data(attacker_data, sample=sample)

        shadow_model = import_model(shadow_model_def)
        shadow_model.train(train_data=(train_x, train_y), test_data=(test_x, test_y))
        
        print('Gathering training data for attack model')
        attack_i_x, attack_i_y = [], []
        (train_x, train_y), (test_x, test_y) = balance_attack_data(train_x, train_y, test_x, test_y)
        attack_i_x.append(shadow_model.evaluate(train_x))
        attack_i_y.append(np.ones(len(train_x)))
        attack_i_x.append(shadow_model.evaluate(test_x))
        attack_i_y.append(np.zeros(len(test_x)))
        
        attack_x += attack_i_x
        attack_y += attack_i_y
        attack_classes.append(np.concatenate([train_y, test_y]))
        
        shadow_model.clear_model()
        
    # train data for attack model
    attack_x = np.vstack(attack_x)
    attack_y = np.concatenate(attack_y)
    attack_x = attack_x.astype('float32')
    attack_y = attack_y.astype('int32')
    attack_classes = np.concatenate(attack_classes)

    train_x, train_y = attack_x, attack_y

    train_classes, test_classes = np.squeeze(attack_classes), np.squeeze(classes)
    train_indices = np.arange(len(train_classes))
    test_indices = np.arange(len(test_classes))
    unique_classes = np.unique(np.concatenate([train_classes, test_classes]))

    pred = []
    y = []
    y_c = []
    x = []
    x_o = []
        
    for c in unique_classes:
        print('Training Attack Model for class: {}'.format(c+1))
        c_train_indices = train_indices[train_classes == c]
        c_train_x, c_train_y = train_x[c_train_indices], train_y[c_train_indices]
        c_test_indices = test_indices[test_classes == c]
        c_test_x, c_test_y = attack_test_x[c_test_indices], attack_test_y[c_test_indices]
        c_dataset_train = (c_train_x, c_train_y)
        c_dataset_test = (c_test_x, c_test_y)
        attack_model_def.train(train_data=c_dataset_train, test_data=c_dataset_test)
        
        pred.append(attack_model_def.evaluate(c_test_x))
        y.append(c_test_y)
        x.append(c_test_x)
        y_c.append(np.array([c]*len(c_test_indices)))
        x_o.append(test_o_data[c_test_indices])
        
        attack_model_def.clear_model()
            
    pred = np.concatenate(pred)
    y = np.concatenate(y)
    x = np.concatenate(x)
    y_c = np.concatenate(y_c)
    x_o = np.concatenate(x_o)
    
    return {'attack_test_y': y, 'attack_test_x': x, 'preds': pred, 'target_y': y_c, 'target_x': x_o, 'labels': labels}
